# -*- ispell-local-dictionary: "portugues"; org-export-headline-levels: 5; -*-
#+PROPERTY: header-args:js  :exports code
#+PROPERTY: header-args:elm  :exports code

# Revisão de Literatura --------------------------------------------------------

Um programa de computador é expresso por um conjunto de sentenças em alguma
linguagem de programação.[fn:statement]
A forma como as sentenças de uma linguagem são executadas pelo computador é
definida por um /modelo de computação/ cite:roy2004.

O código fonte de um programa consiste de uma série de instruções que expressam
uma sequência de comandos a se seguir durante a execução — esse período é
conhecido como /tempo de execução/, do inglês /runtime/.
Tradicionalmente, as sentenças de uma linguagem de programação denotam essa
sequência de forma explícita.
Tais linguagens são baseadas no modelo /imperativo/ de computação, e são
denominadas /linguagens imperativas/.

* Linguagens de Programação
  <<sec:langs>>

  Linguagens de programação são mais simples que linguagens naturais, no
  entanto, elas ainda podem conter uma sintaxe surpreendentemente rica, um
  conjunto de abstrações, e bibliotecas auxiliares.
  Esse é essencialmente o caso de linguagens usadas para resolver problemas
  reais do dia-a-dia.
  \textcite{roy2004} as chamam de linguagens /práticas/, que são “\textelp{}
  como a caixa de ferramentas de um mecânico experiente: há várias ferramentas
  diferentes para finalidades diferentes e todas estão lá por uma razão.” (p.
  33; tradução nossa).

  Todas as linguagens de programação possuem elementos primitivos para a
  descrição de dados e das transformações, ou processos, aplicados à eles —
  como a adição de dois números ou a seleção de um item de uma coleção.
  Essas primitivas são definidas por regras de sintaxe — a gramática — e pela
  semântica — o significado.

  # dados
  # processos
  # -> sintaxe
  # -> semântica
  Linguagens imperativas geralmente oferecem comandos para lidar com estado em
  tempo de execução, como declaração e atribuição de variáveis, e comandos
  para controlar o caminho que o programa deve seguir, como os que decidem a
  ordem de execução das sentenças — na literatura essa ordem é chamada de
  /fluxo de controle/ de um programa.

  # -> estado
  Durante sua execução o programa segue um caminho de acordo com seu /estado/
  interno — ou /memória/, o que um programa se lembra enquanto está ‘rodando’.
  Programas com estado interno, ou /statefull/ em inglês, são projetados para
  lembrar de eventos anteriores ou de interações com o usuário.
  A informação recordada é denominada o estado do programa cite:rouse2005.

* Paradigmas de Programação
  Programação é uma disciplina extensa, e linguagens práticas de programação
  geralmente são bastante complicadas.
  Felizmente, as ideias importantes de linguagens de programação são simples
  cite:roy2009.
  Um /paradigma de programação/:

  #+BEGIN_EXPORT latex
  \begin{citacao}
    \textelp{} é uma abordagem para a programação de um computador baseada em
    uma teoria matemática ou um conjunto coerente de princípios.
    \cite[p.~10; tradução nossa]{roy2009}
  \end{citacao}
  #+END_EXPORT

  É mais interessante focar em paradigmas de programação do que em linguagens,
  porque há muito menos paradigmas que linguagens, como pode-se notar na Figura
  ref:img:LangsParadigmsConcepts cite:roy2009.
  Segundo textcite:roy2009:

  #+BEGIN_EXPORT latex
  \begin{citacao}
    Os conceitos são os elementos primitivos básicos usados para construir os
    paradigmas. Muitas vezes dois paradigmas que parecem muitos diferentes (por
    exemplo, programação funcional e programação orientada a objetos) diferem
    por apenas um conceito. (p. 13; tradução nossa)
  \end{citacao}
  #+END_EXPORT

  #+BEGIN_EXPORT latex
  \begin{figure}[ht]
    \caption{Linguagens, paradigmas, e conceitos de programação.} \centering
    \includegraphics[width=12cm]{./fig/roy2009_languages_paradigms_and_concepts.jpeg}

    \small Fonte: \textcite[p.~12]{roy2009}.
    \label{img:LangsParadigmsConcepts}
  \end{figure}
  #+END_EXPORT

  Da mesma forma que em engenharia de software (como um processo) pode-se adotar
  diferentes metodologias de desenvolvimento, em linguagens de programação (como
  modelos de computação) é desejável utilizar diferentes paradigmas de
  programação.
  Linguagens tradicionais como Java e C++ dão suporte a um ou dois paradigmas
  diferentes.
  “Isso é lamentável, pois problemas de programação diferentes precisam de
  conceitos diferentes de programação para serem resolvidos claramente.”
  [[cite:roy2009][p. 10]].

  textcite:roy2009 defende o uso de um modelo de programação /multiparadigma/,
  porque:

  #+BEGIN_EXPORT latex
  \begin{citacao}
    Idealmente, uma linguagem deveria dar suporte a vários conceitos de forma
    bem integrada, para que o programador possa escolher os conceitos certos
    sempre que forem necessários, sem que um complique o outro.
    (p.~10; tradução nossa)
  \end{citacao}
  #+END_EXPORT

  Apesar de linguagens tradicionais não dar suporte a esse modelo, entender os
  conceitos certos pode melhorar a forma de programação, mesmo em linguagens que
  não dê suporte direto a eles, assim como programação orientada a objetos é
  possível em C com a atitude adequada cite:roy2009.

  textcite:roy2009 apresenta quatro modelos importantes que simplificam
  programação concorrente em relação à linguagens convencionais: /concorrência
  declarativa/, /programação funcional reativa/, /programação síncrona
  discreta/, e /programação com restrições/.

  No modelo declarativo de concorrência o resultado de um programa pode ser
  calculado incrementalmente.
  “Se a entrada de um programa concorrente é dada incrementalmente, então o
  programa também irá calcular o resultado de saída incrementalmente.”
  [[cite:roy2004][p. 238; tradução nossa]].
  Esses paradigmas não possuem condições de corrida, /‘race conditions’/ em
  inglês.


* Programação Funcional
  Programação Funcional (PF) é assim chamada porque sua operação básica é a
  aplicação de funções à argumentos cite:hughes1990.
  Lisp foi a primeira linguagem de programação funcional.
  Criada em 1958 originalmente como uma notação matemática para programas de
  computador, influenciada pela do /cálculo lambda/ de Alonzo Church.

  Na matemática a ideia de /quadrado de um número/ pode ser expressa
  algebricamente como uma função $f(x)=x*x$.
  Em Elm, a ideia de quadrado pode ser expressa como src_elm{quadrado x = x *
  x}.
  A expressão pode ser lida em português da seguinte forma: “O quadrado de algo
  é ele multiplicado por ele mesmo.”

  A expressão algébrica denota uma função $f$ que relaciona um número $x$ com
  seu quadrado, ou transforma $x$ em seu quadrado.
  A expressão em Elm define uma função src_elm{quadrado} que transforma o
  parâmetro src_elm{x} em seu quadrado.
  textcite:roy2009 descreve uma função no contexto da PF:

  #+BEGIN_EXPORT latex
  \begin{citacao}
    Functions are mathematical functions: when called with the same arguments,
    they always give the same results. Functions do not change. In the real world,
    things are different. There are few real-world entities that have the timeless
    behavior of functions. Organisms grow and learn. When the same stimulus is
    given to an organism at different times, the reaction will usually be
    different. (p. 26)
  \end{citacao}
  #+END_EXPORT

  Um programa funcional é uma expressão a ser avaliada, no contexto de um
  conjunto de definições — principalmente definições de funções.
  Por exemplo, dada as definições de função em ref:code:programfnDefinitions, um
  programa pode consistir da expressão src_elm{dobrar (somar 2 3)} e o resultado
  do programa então seria src_elm{10} cite:noble1994.

  #+BEGIN_EXPORT latex
  \begin{listing}[H]
    \centering
    \caption{Definição das funções \texttt{somar} e \texttt{dobrar}.}
    \begin{minted}[linenos=false]{elm}
      somar x y = x + y
      dobrar z = 2 * z
    \end{minted}
    \small Fonte: Adaptado de \textcite{noble1994}.
    \label{code:programfnDefinitions}
  \end{listing}
  #+END_EXPORT

  Funções são consideradas /cidadãs de primeira classe — do inglês ‘first-class
  citizens’/, e podem ser passadas como argumentos da mesma forma que qualquer
  outro tipo de dado.
  Uma função é definida para ter um certo número de argumentos (sua /aridade/),
  mas se for calculada com menos argumentos o resultado é outra função.
  Isso permite funções como as definidas em ref:code:currying, onde ~inc~ recebe
  um número e adiciona ~1~ a ele, e ~tres~ aplica ~f~, uma dada função, três
  vezes à qualquer argumento em que ~f~ normalmente aceitaria, por exemplo: a
  expressão ~tres inc 2~ resulta no valor ~5~ cite:noble1994.

  #+BEGIN_EXPORT latex
  \begin{listing}[H]
    \centering \caption{\emph{Currying}.}
    \begin{minted}[linenos=false]{elm}
      inc = somar 1
      tres f = f >> f >> f >>
    \end{minted}
    \small Fonte: Adaptado de \textcite{noble1994}.
    \label{code:currying}
  \end{listing}
  #+END_EXPORT


* Footnotes

[fn:statement]
Uma sentença (/statement/) pode conter uma ou várias expressões ou instruções.
Uma única instrução numa linguagem de alto nível pode representar múltiplas
instruções de máquinas.
Programas consistem de instruções e expressões.
Uma expressão é um grupo de símbolos que representa um valor.
